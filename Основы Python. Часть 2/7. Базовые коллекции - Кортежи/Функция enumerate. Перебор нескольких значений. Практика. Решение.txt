# Задача 1. Саботаж!
#
# Какой-то нехороший человек решил подпортить жизнь frontend-разработчикам и добавил в код сайта символ ~ (тильда).
# Но программисты быстро решили эту проблему, пройдясь по всему коду маленькой программой.
#
# Пользователь вводит строку. Напишите программу, которая проходит по строке и выводит в консоль индексы символа ~.
# Для решения этой задачи (и остальных тоже) используйте функцию enumerate.
#
#
#
# Пример:
#
# Строка: so~mec~od~e
#
#
#
# Ответ: 2 6 9
#
#
#
import random


def get_indexes(where_to_search, what_to_search):
    return [str(index) for index, letter in enumerate(where_to_search) if letter == what_to_search]


text = input("Введите текст: ")
print("Ответ:", " ".join(get_indexes(text, "~")))

# Задача 2. Словари из списков
#
# Создайте два списка, в каждом из которых лежит 10 случайных букв алфавита (могут повторяться).
# Затем для каждого списка создайте словарь из пар «индекс — значение» и выведите оба словаря на экран.
#
# Подсказка: random
#
#
#
# Пример:
#
# Первый список: ['й', 'р', 'с', 'г', 'а', 'а', 'т', 'ж', 'е', 'к']
#
# Второй список: ['д', 'а', 'а', 'в', 'т', 'ж', 'р', 'б', 'й', 'р']
#
#
#
# Первый словарь: {0: 'й', 1: 'р', 2: 'с', 3: 'г', 4: 'а', 5: 'а', 6: 'т', 7: 'ж', 8: 'е', 9: 'к'}
#
# Второй словарь: {0: 'д', 1: 'а', 2: 'а', 3: 'в', 4: 'т', 5: 'ж', 6: 'р', 7: 'б', 8: 'й', 9: 'р'}
#
#
#

# Так как у нас нет функции, которая генерирует случайную букву, то нам надо либо создаст список всех букв и выбирать из них случайные
# Либо нам нужно генерировать случайное число, которое можно преобразовать в букву по таблице Unicodе.

# Первый вариант проще, можете реализовать его самостоятельно, второй посложнее, реализуем его вместе:
print(ord("а"), ord("я"))  # посмотрим с какого числа начинаются русские буквы и где заканчиваются (ё искать не будем)


def get_random_letter(n):
    return random.choices([chr(i) for i in range(ord("а"), ord("я"))], k=n)


first_letters = get_random_letter(10)
second_letters = get_random_letter(10)
print(first_letters)
print(second_letters)

first_dictionary = dict(enumerate(first_letters))
second_dictionary = dict(enumerate(second_letters))
print(first_dictionary)
print(second_dictionary)


# Задача 3. Универсальная программа
#
# Один заказчик попросил нас написать небольшой скрипт для своих криптографических нужд.
# При этом он заранее предупредил, что скрипт должен уметь работать с любым итерируемым типом данных.
#
# Напишите функцию, которая возвращает список из элементов итерируемого объекта (кортежа, строки, списка, словаря), у которых индекс чётный.
#
#
#
# Пример 1:
#
# Допустим, есть такая строка: 'О Дивный Новый мир!'
#
#
#
# Результат: ['О', 'Д', 'в', 'ы', ' ', 'о', 'ы', ' ', 'и', '!']
#
#
#
# Пример 2:
#
# Допустим, есть такой список: [100, 200, 300, 'буква', 0, 2, 'а']
#
#
#
# Результат: [100, 300, 0, 'а']
#
#
#
# Примечание: для проверки типа можно использовать функцию
#
# isinstance(<элемент>, <тип данных>), которая возвращает True, если элемент принадлежит к этому типу данных,
# и возвращает False в противном случае.

def return_even_elements(data):
    result = []
    if isinstance(data, dict):
        data = data.values()
    for index, value in enumerate(data):
        if index % 2 == 0:
            result.append(value)
    return result


print(return_even_elements('О Дивный Новый мир!'))
print(return_even_elements([100, 200, 300, 'буква', 0, 2, 'а']))
print(return_even_elements({0: 'е', 1: 'о', 2: 'ч', 3: 'ы', 4: 'в', 5: 'н', 6: 'д', 7: 'а', 8: 'ш', 9: 'ц'}))